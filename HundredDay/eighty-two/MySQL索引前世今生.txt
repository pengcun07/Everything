MySQL索引前世今生

什么是索引？
	在关系数据库中，索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构，
	它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。
	
	索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。

	MySQL 5.5 以后 InnoDB 储引擎使用的索引数据结构主要用：B+Tree；

索引的优缺点
	索引的优点如下：
		索引大大减小了服务器需要扫描的数据量。
		索引可以帮助服务器避免排序和临时表。
		索引可以将随机 I/O 变成顺序 I/O。

	索引的缺点如下：
		虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行 INSERT、UPDATE 和 DELETE。因为更新表时，MySQL 不仅要保存数据，还要保存索引文件。
		建立索引会占用磁盘空间的索引文件。一般情况这个问题不算严重，但如果你在一个大表上创建了多种组合索引，且伴随大量数据量插入，索引文件大小也会快速膨胀。
		如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。
		对于非常小的表，大部分情况下简单的全表扫描更高效。

	因此应该只为最经常查询和最经常排序的数据列建立索引。（MySQL 同一个数据表里的索引总数限制为 16 个）


那 B+树是什么样的数据结构？MySQL 索引又是为什么选择了 B+树呢？
	其实最终选用 B+树是经历了漫长的演化：
		二叉排序树 → 二叉平衡树 → B-Tree（B树） → B+Tree（B+树）
		
B+Tree 索引的前世今生
	二叉排序树[二叉搜索树]
		1.若左子树不空,它的左子树的孩子节点值都要小于它本身，
		2.若右子树不空，它的右子树的孩子节点值都要大于它本身。
		3.左、右子树也分别为二叉排序树；		
		如果所有节点都满足这个条件，那么它就是二叉排序树。

	AVL 树（自平衡二叉查找树）
		1.本身首先是一棵二叉搜索树。
		2.带有平衡条件：每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1。
		
	B 树（Balanced Tree）多路平衡查找树，多叉的
	B 树的特点如下：
		1.所有键值分布在整个树中。
		2.任何关键字出现且只出现在一个节点中。
		3.搜索有可能在非叶子节点结束。
		4.在关键字全集内做一次查找，性能逼近二分查找算法。
		5.自动层次控制；
		
	B+Tree (B+树是 B 树的变体，也是一种多路搜索树)
		1.每个结点至多有m个子女； [2] 
		2.除根结点外，每个结点至少有[m/2]个子女，根结点至少有两个子女； [2] 
		3.有k个子女的结点必有k个关键字。
	B+ 树的优点，比较的次数均衡，减少了 I/O 次数，提高了查找速度，查找也更稳定：
		B+树的磁盘读写代价更低。
		B+树的查询效率更加稳定。

为什么 MySQL 索引选择了 B+树而不是 B 树？
	原因有如下两点：
	B+树更适合外部存储（一般指磁盘存储），由于内节点（非叶子节点）不存储 data，所以一个节点可以存储更多的内节点，每个节点能索引的范围更大更精确。
	也就是说使用 B+树单次磁盘 I/O 的信息量相比较 B 树更大，I/O 效率更高。

	MySQL 是关系型数据库，经常会按照区间来访问某个索引列，B+树的叶子节点间按顺序建立了链指针，加强了区间访问性，所以 B+树对索引列上的区间范围查询很友好。
	而 B 树每个节点的 key 和 data 在一起，无法进行区间查找。

程序员，你应该知道的索引知识点
	1.回表查询
		比如你创建了 name， age 索引 name_age_index，查询数据时使用了：
		select * from table where name ='陈哈哈' and age = 26;
		由于附加索引中只有 name 和 age，因此命中索引后，数据库还必须回去聚集索引中查找其他数据，这就是回表，这也是你背的那条：少用 select * 的原因。

	2.索引覆盖
		结合回表会更好理解，比如上述 name_age_index 索引，有查询：
		select name， age from table where name ='陈哈哈' and age = 26;
		此时 select 的字段 name，age 在索引 name_age_index 中都能获取到，所以不需要回表，满足索引覆盖，直接返回索引中的数据，效率高。
		
	3.最左前缀原则
		B+树的节点存储索引顺序是从左向右存储，在匹配的时候自然也要满足从左向右匹配。
		通常我们在建立联合索引的时候，也就是对多个字段建立索引，相信建立过索引的同学们会发现，无论是 Oracle 还是 MySQL 都会让我们选择索引的顺序。
		比如我们想在 a，b，c 三个字段上建立一个联合索引，我们可以选择自己想要的优先级，a、b、c，或者是 b、a、c 或者是 c、a、b 等顺序。

	4.索引下推优化
		还是索引 name_age_index，有如下 sql：
		select * from table where name like '陈%' and age > 26；
			该语句有两种执行可能：
			命中 name_age_index 联合索引，查询所有满足 name 以"陈"开头的数据， 然后回表查询所有满足的行。
			命中 name_age_index 联合索引，查询所有满足 name 以"陈"开头的数据，然后顺便筛出 age>20 的索引，再回表查询全行数据。
			显然第 2 种方式回表查询的行数较少，I/O 次数也会减少，这就是索引下推。所以不是所有 like 都不会命中索引

使用索引时的注意事项

	1.索引不会包含有 null 值的列
	只要列中包含有 null 值都将不会被包含在索引中，复合索引中只要有一列含有 null 值，
	那么这一列对于此复合索引就是无效的。所以我们在数据库设计时建议不要让字段的默认值为 null。

	2.使用短索引
	对串列进行索引，如果可能应该指定一个前缀长度。
	例如，如果有一个 char（255）的列，如果在前 10 个或 20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。
	短索引不仅可以提高查询速度而且可以节省磁盘空间和 I/O 操作。

	3.索引列排序
	查询只使用一个索引，因此如果 where 子句中已经使用了索引的话，那么 order by 中的列是不会使用索引的。
	因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。

	4.like 语句操作
	一般情况下不推荐使用 like 操作，如果非使用不可，如何使用也是一个问题。like “%陈%” 不会使用索引而 like “陈%”可以使用索引。

	5.不要在列上进行运算
	这将导致索引失效而进行全表扫描，例如：
	SELECT * FROM table_name WHERE YEAR(column_name)<2017;

	6.不使用 not in 和 <> 操作
	这不属于支持的范围查询条件，不会使用索引。

































